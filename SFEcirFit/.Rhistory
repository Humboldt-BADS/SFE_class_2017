library(stats4)
library(quantmod)
library(sde)
rm(list = ls(all = TRUE))
estimateCIR_OLS <- function(y, dt = 1/256, correction = 0.004){
value <- y + correction
diff <- diff(value, 1)
sq_r <- sqrt(value)[-length(value)]
# calculate variables for CIR OLS estimation
y <- diff/sq_r
x1 <- dt/sq_r
x2 <- sq_r*dt
#estimate OLS without intercept
OLS <- lm(y~x1+x2 - 1)
sigma <- summary(OLS)$sigma                       # diffusion estimate
a <- OLS$coefficients[2]*-1                       # convergence speed estimate
b <- OLS$coefficients[1]/OLS$coefficients[2]*-1   # long time mean
return(c(LTmean_b = b, convSpeed_a = a, sigma = sigma))
}
estimateCIR_ML <- function(y, start_a, start_b, start_sigma, dt = 1/256, seed = 42, correction = 0.004){
set.seed(seed) # set inital seed
y <- y + correction # correct ts
# define CIR function
CIR <- function(theta1, theta2, theta3) {
n=length(y)
dt=1/256
return(-sum(dcCIR(x=y[2:n], Dt=dt, x0=y[1:(n-1)], theta=c(theta1, theta2, theta3), log=T)))
}
#estimate ML based on start values (here OLS)
fit <- mle(CIR, start=list(theta1=as.numeric(start_a * start_b),
theta2=as.numeric(-start_a),
theta3=as.numeric(start_sigma)),
method='L-BFGS-B',
lower=c(0.005,0.01,0.01),
upper=c(1,Inf,1))
result <- c(LTmean_b = coef(fit)[1],  convSpeed_a = coef(fit)[2], sigma = coef(fit)[3])
return(result)
}
y <- read.csv(file = "SFM1 Quantlet/eonia_clean.csv")
getwd()
y <- read.csv(file = "eonia_clean.csv")
start <- match("1999-01-04", y$Date)
end <- match("2012-12-31", y$Date)
y <- y[start:end, 2]
OLSestimates1 <- estimateCIR_OLS(y, correction = 0)
MLestimates1 <- estimateCIR_ML(y,
start_a = OLSestimates1[2],
start_b = OLSestimates1[1],
start_sigma = OLSestimates1[3],
correction = 0)
OLSestimates1
MLestimates1
y <- read.csv(file = "eonia_clean.csv")
start <- match("1999-01-04", y$Date)
end <- length(y$Value)
y <- y[start:end, 2]
OLSestimates2 <- estimateCIR_OLS(y)
MLestimates2 <- estimateCIR_ML(y,
start_a = OLSestimates2[2],
start_b = OLSestimates2[1],
start_sigma = OLSestimates2[3])
estimateCIR_ML <- function(y, start_a, start_b, start_sigma, dt = 1/256, seed = 42, correction = 0.004){
set.seed(seed) # set inital seed
y <- y + correction # correct ts
# define CIR function
CIR <- function(theta1, theta2, theta3) {
n=length(y)
dt=1/256
return(-sum(dcCIR(x=y[2:n], Dt=dt, x0=y[1:(n-1)], theta=c(theta1, theta2, theta3), log=T)))
}
#estimate ML based on start values (here OLS)
fit <- mle(CIR, start=list(theta1=as.numeric(start_a * start_b),
theta2=as.numeric(-start_a),
theta3=as.numeric(start_sigma)),
method='L-BFGS-B',
lower=c(0.0005,0.01,0.01),
upper=c(1,Inf,1))
result <- c(LTmean_b = coef(fit)[1],  convSpeed_a = coef(fit)[2], sigma = coef(fit)[3])
return(result)
}
y <- read.csv(file = "eonia_clean.csv")
start <- match("1999-01-04", y$Date)
end <- match("2012-12-31", y$Date)
y <- y[start:end, 2]
OLSestimates1 <- estimateCIR_OLS(y, correction = 0)
MLestimates1 <- estimateCIR_ML(y,
start_a = OLSestimates1[2],
start_b = OLSestimates1[1],
start_sigma = OLSestimates1[3],
correction = 0)
y <- read.csv(file = "eonia_clean.csv")
start <- match("1999-01-04", y$Date)
end <- length(y$Value)
y <- y[start:end, 2]
OLSestimates2 <- estimateCIR_OLS(y)
MLestimates2 <- estimateCIR_ML(y,
start_a = OLSestimates2[2],
start_b = OLSestimates2[1],
start_sigma = OLSestimates2[3])
set.seed(42)
sde.sim(X0=y[1], theta=c(MLestimates1[1], MLestimates1[2], MLestimates1[3]), model="CIR", N=length(y)) -> X1
set.seed(42)
sde.sim(X0=y[1], theta=c(MLestimates2[1], MLestimates2[2], MLestimates2[3]), model="CIR", N=length(y)) -> X2
plot(X1, main="Cox-Ingersoll-Ross")
plot(X2, main="Cox-Ingersoll-Ross")
sde.sim(X0=y[1], theta=c(MLestimates1[1], MLestimates1[2], MLestimates1[3]), model="CIR", N=length(y)) -> X1
plot(X1, main="Cox-Ingersoll-Ross")
sde.sim(X0=y[1], theta=c(MLestimates1[1], MLestimates1[2], MLestimates1[3]), model="CIR", N=length(y)) -> X1
plot(X1, main="Cox-Ingersoll-Ross")
set.seed(42)
sde.sim(X0=y[1], theta=c(MLestimates1[1], MLestimates1[2], MLestimates1[3]), model="CIR", N=length(y)) -> X1
sde.sim(X0=y[1], theta=c(MLestimates1[1], MLestimates1[2], MLestimates1[3]), model="CIR", N=256) -> X1
plot(X1, main="Cox-Ingersoll-Ross")
library(stats4)
library(quantmod)
library(sde)
rm(list = ls(all = TRUE))
estimateCIR_OLS <- function(y, dt = 1/256, correction = 0.004){
value <- y + correction
diff <- diff(value, 1)
sq_r <- sqrt(value)[-length(value)]
# calculate variables for CIR OLS estimation
y <- diff/sq_r
x1 <- dt/sq_r
x2 <- sq_r*dt
#estimate OLS without intercept
OLS <- lm(y~x1+x2 - 1)
sigma <- summary(OLS)$sigma                       # diffusion estimate
a <- OLS$coefficients[2]*-1                       # convergence speed estimate
b <- OLS$coefficients[1]/OLS$coefficients[2]*-1   # long time mean
return(c(LTmean_b = b, convSpeed_a = a, sigma = sigma))
}
estimateCIR_ML <- function(y, start_a, start_b, start_sigma, dt = 1/256, seed = 42, correction = 0.004){
set.seed(seed) # set inital seed
y <- y + correction # correct ts
# define CIR function
CIR <- function(theta1, theta2, theta3) {
n=length(y)
dt=1/256
return(-sum(dcCIR(x=y[2:n], Dt=dt, x0=y[1:(n-1)], theta=c(theta1, theta2, theta3), log=T)))
}
#estimate ML based on start values (here OLS)
fit <- mle(CIR, start=list(theta1=as.numeric(start_a * start_b),
theta2=as.numeric(-start_a),
theta3=as.numeric(start_sigma)),
method='L-BFGS-B',
lower=c(0.0005,0.01,0.01),
upper=c(1,Inf,1))
result <- c(LTmean_b = coef(fit)[1],  convSpeed_a = coef(fit)[2], sigma = coef(fit)[3])
return(result)
}
y <- read.csv(file = "eonia_clean.csv")
start <- match("1999-01-04", y$Date)
end <- length(y$Value)
y <- y[start:end, 2]
OLSestimates2 <- estimateCIR_OLS(y)
OLSestimates2
y <- read.csv(file = "eonia_clean.csv")
start <- match("1999-01-04", y$Date)
end <- match("2012-12-31", y$Date)
y <- y[start:end, 2]
OLSestimates1 <- estimateCIR_OLS(y, correction = 0)
MLestimates1 <- estimateCIR_ML(y,
start_a = OLSestimates1[2],
start_b = OLSestimates1[1],
start_sigma = OLSestimates1[3],
correction = 0)
MLestimates1 <- estimateCIR_ML(y,
start_a = OLSestimates1[2],
start_b = OLSestimates1[1],
start_sigma = OLSestimates1[3],
correction = 0)
y <- read.csv(file = "eonia_clean.csv")
start <- match("1999-01-04", y$Date)
end <- length(y$Value)
y <- y[start:end, 2]
OLSestimates2 <- estimateCIR_OLS(y)
MLestimates2 <- estimateCIR_ML(y,
start_a = OLSestimates2[2],
start_b = OLSestimates2[1],
start_sigma = OLSestimates2[3])
set.seed(42)
sde.sim(X0=y[1], theta=c(MLestimates2[1], MLestimates2[2], MLestimates2[3]), model="CIR", N=length(y)) -> X2
plot(X2, main="Cox-Ingersoll-Ross")
MLestimates2 <- estimateCIR_ML(y,
start_a = OLSestimates2[2],
start_b = OLSestimates2[1],
start_sigma = OLSestimates2[3])
df_3Meuribor  <- read.csv("BBK01.ST0316.csv", sep = ";")
df_3Meuribor  <- read.csv("../BBK01.ST0316.csv", sep = ";")
clean.data <- function(df_data){
names(df_data)  <- c("Date", "Value", "Comment")
drops           <- c(seq(1:4), length(df_data[,1]))                         # drop head and tail of the data
df_data         <- df_data[-drops,]                                         # drop head and tail of the data
df_data         <- df_data[-which(df_data$Comment=="Kein Wert vorhanden"),] # drop missing values (weekends)
df_data$Value   <- as.numeric(gsub(",", ".", df_data$Value))/100            # convert per cent values into numbers
df_data$Date    <- as.Date(df_data$Date)                                    # convert time flags into dates
df_data$Differences <- c(0,diff(df_data$Value))                             # determine the differences
return(df_data)
}
df_3Meuribor      <- clean.data(df_3Meuribor)
write(df_3Meuribor, "3Meuribor_clean.csv")
df_3Meuribor
df_3Meuribor      <- df_3Meuribor[,1:2]
df_3Meuribor
write.csv(df_3Meuribor, "3Meuribor_clean.csv")
library(stats4)
library(quantmod)
library(sde)
estimateCIR_OLS <- function(y, dt = 1/256, correction = 0.004){
value <- y + correction
diff <- diff(value, 1)
sq_r <- sqrt(value)[-length(value)]
# calculate variables for CIR OLS estimation
y <- diff/sq_r
x1 <- dt/sq_r
x2 <- sq_r*dt
#estimate OLS without intercept
OLS <- lm(y~x1+x2 - 1)
sigma <- summary(OLS)$sigma                       # diffusion estimate
a <- OLS$coefficients[2]*-1                       # convergence speed estimate
b <- OLS$coefficients[1]/OLS$coefficients[2]*-1   # long time mean
return(c(LTmean_b = b, convSpeed_a = a, sigma = sigma))
}
estimateCIR_ML <- function(y, start_a, start_b, start_sigma, dt = 1/256, seed = 42, correction = 0.004){
set.seed(seed) # set inital seed
y <- y + correction # correct ts
# define CIR function
CIR <- function(theta1, theta2, theta3) {
n=length(y)
dt=1/256
return(-sum(dcCIR(x=y[2:n], Dt=dt, x0=y[1:(n-1)], theta=c(theta1, theta2, theta3), log=T)))
}
#estimate ML based on start values (here OLS)
fit <- mle(CIR, start=list(theta1=as.numeric(start_a * start_b),
theta2=as.numeric(-start_a),
theta3=as.numeric(start_sigma)),
method='L-BFGS-B',
lower=c(0.0005,0.01,0.01),
upper=c(1,Inf,1))
result <- c(LTmean_b = coef(fit)[1],  convSpeed_a = coef(fit)[2], sigma = coef(fit)[3])
return(result)
}
y <- read.csv(file = "eonia_clean.csv")
start <- match("1999-01-04", y$Date)
end <- match("2012-12-31", y$Date)
y <- y[start:end, 2]
OLSestimates1 <- estimateCIR_OLS(y, correction = 0)
MLestimates1 <- estimateCIR_ML(y,
start_a = OLSestimates1[2],
start_b = OLSestimates1[1],
start_sigma = OLSestimates1[3],
correction = 0)
y <- read.csv(file = "eonia_clean.csv")
start <- match("1999-01-04", y$Date)
end <- length(y$Value)
y <- y[start:end, 2]
OLSestimates2 <- estimateCIR_OLS(y)
MLestimates2 <- estimateCIR_ML(y,
start_a = OLSestimates2[2],
start_b = OLSestimates2[1],
start_sigma = OLSestimates2[3])
y <- read.csv(file = "eonia_clean.csv")
start <- match("1999-01-04", y$Date)
end <- length(y$Value)
y <- y[start:end, 2]
OLSestimates3 <- estimateCIR_OLS(y, correction = 0)
y <- read.csv(file = "3Meuribor_clean.csv")
start <- match("1999-01-04", y$Date)
end <- length(y$Value)
y <- y[start:end, 2]
OLSestimates4 <- estimateCIR_OLS(y, correction = 0)
MLestimates4 <- estimateCIR_ML(y,
start_a = OLSestimates4[2],
start_b = OLSestimates4[1],
start_sigma = OLSestimates4[3],
correction = 0)
OLSestimates1
MLestimates1
OLSestimates2
MLestimates2
OLSestimates4
